import NatNet
import NatNet.DataDescription
import time
import functools
import numpy as np

START_TIME = 0
CAPTURE_TIME = 1
X = 2
Y = 3
Z = 4
QW = 5
QX = 6
QY = 7
QZ = 8

def on_data_accumulate(dataFrame, start_time, data_buffer, start_frame):
    """
    Called every frame of automatically by NatNet.
    Adds frames of data to the datta_buffer.
    """

    """
    The frame line, example: frame,0,0.00000000,0,0

    format: frame: Details frame of exported data in the following format:
        -- Frame Index (integer)"
        -- Time Stamp (double) in seconds"
        -- Rigid Body Count (integer) number of rigid bodies tracked in current frame
        -- Rigid Body ID, Position, Quaternion Orientation, and Euler Angle Orientation >for each tracked rigid body< (ID, x,y,z, qx, qy, qz, qw, yaw, pitch, roll)
    """
    frame_buf = []
    if start_frame == []:
        start_frame.append(dataFrame.iFrame)
    iFrame = dataFrame.iFrame-start_frame[0]
    frame = "frame,"+str(iFrame)+","+str(dataFrame.Latency)+","+str(len(dataFrame.RigidBodies))+","
    #frame = "frame,"+str(iFrame)+","+str(dataFrame.TimeEstimate)+","+str(len(dataFrame.RigidBodies))+","

    id = 0;
    for r in dataFrame.RigidBodies:
        yaw, pitch, roll = 0, 0, 0
        frame+= str(id) + "," + str(r.x)+","+str(r.y)+","+str(r.z)+","+str(r.qx)+","+str(r.qy)+","+str(r.qz)+","+str(r.qw)+","+str(yaw)+","+str(pitch)+","+str(roll)+","
        id += 1

    allMarkers = None
    for markerSet in dataFrame.MarkerSets:
        if markerSet.name == "all":
            allMarkers = markerSet

    frame+=str(len(allMarkers.markers))+","
    for idx, marker in enumerate(allMarkers.markers):
        #TODO get actual index
        frame+=str(marker[0])+","+str(marker[0])+","+str(marker[0])+","+str(idx)+","
    frame_buf.append(frame)

    """
    output each trackable line. Example: trackable,"rbt",4,5,0.01211172,0.00230224,0.05883896,-0.01953046,0.00195556,0.05511546,-0.01090771,0.00318372,-0.01188982,0.02377369,-0.00373099,-0.04947186,-0.00544728,-0.00371053,-0.05259275

    format: trackable: Extended information for current frame:"
        -- Frame Index (integer)"
        -- Time Stamp (double) in seconds"
        -- Name (string)"
        -- ID   (integer)"
        -- Frames Since Last Tracked (integer). 0=currently tracked"
        -- Marker Count (integer)"
        -- Trackable Marker Location >for each marker in trackable< (x,y,z)"
        -- Point Cloud Marker corresponding to each trackable marker (x,y,z). (NAN,NAN,NAN) used for missing Point Cloud Markers."
        -- Marker Tracked (integer) for each marker. 1=track, 0=untracked."
        -- Marker Quality (float) for each marker. 1.0=Highest Quality, 0.0=Lowest Quality"
        -- Mean Error (in mm/marker)"
    """
    id = 0
    for markerSet in dataFrame.MarkerSets:
        id += 1
        if markerSet.name == "all":
            continue
        framesSinceLastTracked = 0 #TODO fix this
        ID = str(id)
        trackable = "trackable,"+str(iFrame)+","+str(dataFrame.Latency)+","+markerSet.name+","+ID+","+str(framesSinceLastTracked) + "," + str(len(markerSet.markers)) + ","
        #trackable marker location
        for marker in markerSet.markers:
            trackable += str(marker[0]) + "," + str(marker[1]) + "," + str(marker[2]) + ","
        #point cloud markers
        for marker in markerSet.markers:
            trackable += str(marker[0]) + "," + str(marker[1]) + "," + str(marker[2]) + ","
        
        for marker in markerSet.markers:
            markerTracked = "NAN"
            trackable += markerTracked +","
        for marker in markerSet.markers:
            quality = "NAN"
            trackable += quality +","

        meanError = "0"; #TODO calculate mean error
        trackable += meanError
        #TODO fix missing trackble fields
        frame_buf.append(trackable)
    data_buffer.append(frame_buf)

def start_collection(client):
    """
    Start natnet collection.
    Returns an array that continually gets populated by natnet.
    """
    buf = []
    startFrame = [] #pass by reference to find first frame.
    client.SetDataCallback(
        functools.partial(on_data_accumulate, start_time = time.time(), data_buffer=buf, start_frame=startFrame))
    return buf #return a reference

def stop_collection(client):
    """
    Stops natnet collection. the buffer array returned by start_collection is now safe to use.
    """
    client.SetDataCallback(None)

def csv_from_data(natnetClient, data_buff, filename):
    """
    Write the data buffer generated by start_collection to file.
    """
    data_file = open(filename, 'wb+')
    header = """comment,"A Modified NaturalPoint Trackable Export Data"
comment,"== "
comment,"Format Information (Some data is ommitted):"
comment,"== "
comment,"== Data is formatted in rows."
comment,"== First entry of each row identifies row type."
comment,"== "
comment,"== Types:"
comment,"== "
comment,"== comment: Comment, you can ignore this information"
comment,"== info: reports number of trackable definitions and"
comment,"==       total number of exported frames"
comment,"== trackable: Details rigid body definition in the following format:"
comment,"==    -- Name (string)"
comment,"==    -- ID   (integer)"
comment,"==    -- Marker Count (integer)"
comment,"==    -- X,Y,Z (float) 3D position of each marker in rigid body"
comment,"== "
comment,"== frame: Details frame of exported data in the following format:"
comment,"==    -- Frame Index (integer)"
comment,"==    -- Time Stamp (double) in seconds"
comment,"==    -- Trackable Count (integer) number of trackables tracked in current frame"
comment,"==    -- Trackable ID, Position, Quaternion Orientation, and Eulers Orientation >for each tracked trackable< (ID, x,y,z, qx, qy, qz, qw, yaw, pitch, roll)"
comment,"==    -- Marker Count (integer) Count of all visibile markers in frame"
comment,"==    -- Marker Detail >for each tracked marker< (x,y,z,id)"
comment,"== trackable: Extended information for current frame:"
comment,"==    -- Frame Index (integer)"
comment,"==    -- Time Stamp (double) in seconds"
comment,"==    -- Name (string)"
comment,"==    -- ID   (integer)"
comment,"==    -- Frames Since Last Tracked (integer). 0=currently tracked"
comment,"==    -- Marker Count (integer)"
comment,"==    -- Trackable Marker Location >for each marker in trackable< (x,y,z)"
comment,"==    -- Point Cloud Marker corresponding to each trackable marker (x,y,z). (NAN,NAN,NAN) used for missing Point Cloud Markers."
comment,"==    -- Marker Tracked (integer) for each marker. 1=track, 0=untracked."
comment,"==    -- Marker Quality (float) for each marker. 1.0=Highest Quality, 0.0=Lowest Quality"
comment,"==    -- Mean Error (in mm/marker)"
comment,"== righthanded: Indicates a right-handed coordinate system"
comment,"== lefthanded: Indicates a left-handed coordinate system"
comment,"== "
"""
    data_file.write(header)
    """
    print c.GetServerDescription()
    time.sleep(.4); #For some reason, this helps with GetDataDescriptions not crashing...
    dataDescriptions = c.GetDataDescriptions()
    for description in dataDescriptions:
        if (isinstance(description, NatNet.DataDescription.RigidBodyDescription)):
            print description
            print description.Name
        if (isinstance(description, NatNet.DataDescription.RigidBodyDescription)):
            print description
            print description.Name
            """
    data_file.write("righthanded\n")
    
    data_file.write("info,framecount,"+str(len(data_buff)+1)+"\n")
    data_file.write("info,version,1\n")
    data_file.write("info,natnetWritten,1\n")

    #Recreate the list of trackables

    #TODO Don't pull directly from strings. Work in Datastructure then convert to string
    #grab the track count off of parsed string


    # {{id} : {[num_markers, num_markers]}}
    id_to_makers = {}
    id_to_names = {}
    for line in data_buff:
        trackables = [x.split(",") for x in line[1:]]
        for trk in trackables:
            id = trk[4]
            name = trk[3]
            if id not in id_to_makers:
                id_to_makers[id] = []
                id_to_names[id] = name
            num_marker = int(trk[6])
            id_to_makers[id].append(num_marker)
    print len(id_to_makers)

    trackables = "info,trackablecount," + str(len(id_to_makers)) + "\n"

    data_file.write(trackables)
    for id, values in id_to_makers.items():
        trackable = "trackable," + id_to_names[id]+","+str(id) +"," +str(max(values))
        #TODO make these positions actual positions. Not used by optitrack for now
        for k in range(max(values)):
            trackable += ",0,0,0"
        trackable += "\n"
        data_file.write(trackable);

    for frame in data_buff:
        for line in frame:
                data_file.write(line + "\n")
    data_file.close()


if __name__ == "__main__":
    c = NatNet.NatNetClient(1)
    b = c.Initialize("", "") #use local host for both. Command Port: 1510, Data Port: 1511
    buf = start_collection(c)
    start = time.time()
    while time.time() - start < 1:
        pass
    stop_collection(c)
    csv_from_data(c, buf, "test/test.csv")